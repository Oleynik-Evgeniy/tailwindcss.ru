---
title: "Режим «на лету»"
shortTitle: "Режим Just-in-Time"
description: "Более быстрый и мощный движок по запросу для Tailwind CSS v2.1+."
featureVersion: 'v2.1+'
---
import { Heading } from '@/components/Heading'
import { TipGood, TipBad, TipInfo } from '@/components/Tip'
import { ThemeReference } from '@/components/ThemeReference'

## <Heading hidden>Обзор</Heading>

<TipInfo>
  <strong className="font-semibold text-blue-900">Эта функция в настоящее время находится на стадии превью.</strong> Предварительные функции не охватываются семантическим управлением версиями, и некоторые детали могут измениться, поскольку мы продолжаем их совершенствовать.
</TipInfo>

Tailwind CSS v2.1 представляет новый своевременный компилятор для Tailwind CSS, который генерирует ваши стили по запросу, когда вы создаете свои шаблоны, вместо того, чтобы создавать все заранее во время начальной сборки.

<div className="relative pb-[calc(9/16*100%)] my-12">
  <iframe
    className="absolute inset-0 h-full w-full"
    src="https://www.youtube.com/embed/3O_3X7InOw8"
    frameBorder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

Это дает множество преимуществ:

- **Молниеносно быстрое время сборки**. Первоначальная компиляция Tailwind с использованием нашего интерфейса командной строки может занять 3–8 секунд, а в проектах webpack может потребоваться более 30–45 секунд, поскольку webpack борется с большими файлами CSS. Эта библиотека может компилировать даже самые большие проекты примерно за 800 мс _(с инкрементальной перестройкой всего за 3 мс)_, независимо от того, какой инструмент сборки вы используете.
- **Каждый вариант включен из коробки**. Такие варианты, как `focus-visible`, `active`, `disabled` и другие обычно не включаются по умолчанию из-за соображений размера файла. Поскольку эта библиотека генерирует стили по запросу, вы можете использовать любой вариант, какой захотите, когда захотите. Вы даже можете складывать их, например, `sm:hover:active:disabled:opacity-75`. Никогда больше не настраивайте свои варианты.
- **Создание произвольных стилей без написания собственного CSS.** Когда-нибудь требовалось какое-то сверхспецифическое значение, которое не было частью вашей системы дизайна, например `top: -113px` для причудливого фонового изображения? Поскольку стили генерируются по запросу, вы можете просто сгенерировать для этого утилиту по мере необходимости, используя обозначение в квадратных скобках, например `top-[-113px]`. Также работает с вариантами, такими как `md:top-[-113px]`.
- **Ваш CSS идентичен в разработке и продакшене**. Поскольку стили генерируются по мере необходимости, вам не нужно очищать неиспользуемые стили для продакшена, что означает, что вы видите один и тот же CSS во всех средах. Никогда не беспокойтесь о том, что снова случайно удалите важный стиль в продакшене.
- **Повышение производительности браузера в разработке**. Поскольку сборки для разработки такие же маленькие, как и продакшен сборки, браузеру не нужно анализировать и управлять несколькими мегабайтами предварительно сгенерированного CSS. В проектах с сильно расширенными конфигурациями это делает инструменты разработки намного более отзывчивыми.

Чтобы увидеть это в действии, [посмотрите наше анонсирующее видео](https://www.youtube.com/watch?v=3O_3X7InOw8).

## Включение режима JIT

Чтобы включить режим JIT, установите для параметра `mode` значение `'jit'` в файле `tailwind.config.js`:

```diff-js
  // tailwind.config.js
  module.exports = {
+   mode: 'jit',
    purge: [
      // ...
    ],
    theme: {
      // ...
    }
    // ...
  }
```

Поскольку в режиме JIT ваш CSS создается по запросу путем сканирования файлов шаблонов, очень важно настроить опцию `purge` в файле `tailwind.config.js` со всеми вашими путями к шаблонам, иначе ваш CSS будет пуст:

```diff-js
  // tailwind.config.js
  module.exports = {
    mode: 'jit',
+   // Эти пути являются лишь примерами, настройте их в соответствии со структурой вашего проекта
+   purge: [
+     './public/**/*.html',
+     './src/**/*.{js,jsx,ts,tsx,vue}',
+   ],
    theme: {
      // ...
    }
    // ...
  }
```

Теперь, когда вы запускаете свой сервер разработки или сборщик, Tailwind будет генерировать ваши стили по запросу, вместо того, чтобы создавать все заранее.

## Режим просмотра и разовые сборки

За кулисами движок JIT использует свою собственную систему просмотра файлов, чтобы максимально эффективно отслеживать изменения в ваших шаблонах.

По умолчанию Tailwind запускает длительный процесс наблюдения, если `NODE_ENV=development`, и запускается в одноразовом режиме, если `NODE_ENV=production`.

```js
// package.json
{
  // ...
  scripts: {
    // Запустит длительный процесс наблюдения
    "dev": "NODE_ENV=development postcss tailwind.css -o ./dist/tailwind.css -w"
    // Выполним разовую сборку
    "build": "NODE_ENV=production postcss tailwind.css -o ./dist/tailwind.css"
  },
  // ...
}
```

Если кажется, что процесс разовой сборки завис, это почти наверняка из-за `NODE_ENV=development` в вашем сценарии сборки. Чтобы исправить это, вы можете либо установить `NODE_ENV=production`, либо явно указать Tailwind не запускать наблюдатель, установив `TAILWIND_MODE=build` как часть вашего скрипта.

```js
// package.json
{
  // ...
  scripts: {
    // Запустит длительный процесс наблюдения
    "dev": "TAILWIND_MODE=watch NODE_ENV=development postcss tailwind.css -o ./dist/tailwind.css -w"
    // Выполнит разовую сборку разработки
    "build:dev": "TAILWIND_MODE=build NODE_ENV=development postcss tailwind.css -o ./dist/tailwind.css"
    // Выполнит разовую сборку продакшена
    "build:prod": "TAILWIND_MODE=build NODE_ENV=production postcss tailwind.css -o ./dist/tailwind.css"
  },
  // ...
}
```

## Новые возможности

### Все варианты включены

Поскольку стили создаются по запросу, нет необходимости настраивать, какие варианты доступны для каждого основного плагина.

```html
<input class="disabled:opacity-75">
```

Вы можете использовать такие варианты, как `focus-visible`, `active`, `disabled`, `even` и другие, в сочетании с любой утилитой, не внося никаких изменений в файл `tailwind.config.js`.

### Стекируемые варианты

Все варианты можно комбинировать вместе, чтобы легко ориентироваться в очень специфических ситуациях без написания собственного CSS.

```html
<button class="md:dark:disabled:focus:hover:bg-gray-400">
```

### Поддержка произвольных значений

Многие утилиты поддерживают произвольные значения с использованием новой записи в квадратные скобки, чтобы указать, что вы «вырываете» свою дизайн-систему.

```html
<!-- Размеры и расположение -->
<img class="absolute w-[762px] h-[918px] top-[-325px] right-[62px] md:top-[-400px] md:right-[80px]" src="/crazy-background-image.png">

<!-- Цвета -->
<button class="bg-[#1da1f1]">Поделиться в Твиттере</button>

<!-- Сложные сетки -->
<div class="grid-cols-[1fr,700px,2fr]">
  <!-- ... -->
</div>
```

Это очень полезно для создания идеальных по пикселям дизайнов, где есть несколько элементов, требующих гиперспецифических стилей, например, тщательно расположенное фоновое изображение на маркетинговом сайте.

Скорее всего, в будущем мы добавим некоторую форму «строгого режима» для требовательных к власти руководителей команд, которые не доверяют своим коллегам ответственно использовать эту функцию.

Обратите внимание, что вам все равно нужно [писать очищаемый HTML](https://tailwindcss.com/docs/optimizing-for-production#writing-purgeable-html) при использовании произвольных значений, и ваши классы должны существовать как полные строки для Tailwind чтобы правильно их обнаружить.

<TipBad>Не используйте конкатенацию строк для создания имен классов</TipBad>

```jsx mt-4
<div className={`mt-[${size === 'lg' ? '22px' : '17px' }]`}></div>
```

<TipGood>Динамически выбирайте полное имя класса</TipGood>

```jsx mt-4
<div className={ size === 'lg' ? 'mt-[22px]' : 'mt-[17px]' }></div>
```

Tailwind не включает в себя какую-либо среду выполнения на стороне клиента, поэтому имена классов должны быть статически извлекаемыми во время сборки и не могут зависеть от каких-либо произвольных динамических значений, которые меняются на клиенте. Используйте встроенные стили для этих ситуаций или объедините Tailwind с библиотекой CSS-in-JS, такой как [Emotion](https://emotion.sh/docs/introduction), если это имеет смысл для вашего проекта.

<TipBad>Произвольные значения не могут быть вычислены из динамических значений</TipBad>

```html mt-4
<div class="bg-[{{ userThemeColor }}]"></div>
```

<TipGood>Используйте встроенные стили для действительно динамических или определяемых пользователем значений</TipGood>

```html mt-4
<div style="background-color: {{ userThemeColor }}"></div>
```

### Встроенный важный модификатор

Вы можете сделать любую утилиту важной, добавив в ее начало символ `!`:

```html
<p class="font-bold !font-medium">
  Это будет средний размер, даже если жирный шрифт появится позже в CSS.
</p>
```

`!` всегда стоит в начале имени утилиты, после любых вариантов, но перед любым префиксом:

```html
<div class="sm:hover:!tw-font-bold">
```

Это может быть полезно в редких ситуациях, когда вам нужно повысить специфичность, потому что вы ведете войну с некоторыми стилями, которые вы не контролируете.

## Известные ограничения

Этот новый движок в настоящее время очень близок к паритету функций с `tailwindcss`, и я уверен, что для большинства проектов вы обнаружите, что он работает именно так, как вы ожидаете.

В нашем списке дел все еще есть несколько пунктов, над которыми мы активно работаем:

- Дополнительные параметры PurgeCSS, такие как `safelist`, пока не поддерживаются, поскольку мы фактически не используем PurgeCSS. Тем не менее, мы обязательно добавим способ для классов списков надежных отправителей. На данный момент файл `safelist.txt` где-нибудь в вашем проекте со всеми классами, которые вы хотите добавить в список надежных отправителей, будет работать нормально.
- Вы можете использовать только классы `@apply`, которые являются частью ядра, сгенерированы плагинами или определены в правиле `@layer`. Вы не можете `@apply` произвольных классов CSS, которые не определены в правиле `@layer`.

Мы также устраняем некоторые проблемы совместимости с некоторыми инструментами сборки, такими как Parcel и Snowpack, за которыми вы можете следить в нашем [трекере проблем](https://github.com/tailwindlabs/tailwindcss/issues).

Если вы столкнетесь с другими проблемами или обнаружите какие-либо ошибки, пожалуйста, [откройте проблему](https://github.com/tailwindlabs/tailwindcss/issues/new/choose), чтобы мы могли исправить это.
