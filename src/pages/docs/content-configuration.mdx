---
title: Конфигурация содержимого
shortTitle: Контент
description: Настройка источников контента для вашего проекта.
---

import { TipGood, TipBad } from '@/components/Tip'
import { SnippetGroup } from '@/components/SnippetGroup'
import { ThemeReference } from '@/components/ThemeReference'

В разделе `content` вашего файла `tailwind.config.js` вы настраиваете пути ко всем вашим HTML-шаблонам, компонентам JavaScript и любым другим исходным файлам, которые содержат имена классов Tailwind.

```js tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{html,js}',
    './components/**/*.{html,js}',
  ],
  // ...
}
```

Это руководство охватывает все, что вам нужно знать, чтобы убедиться, что Tailwind генерирует весь CSS, необходимый для вашего проекта.

---

## Настройка исходных путей

Tailwind CSS работает, сканируя все ваши компоненты HTML, JavaScript и любые другие файлы шаблонов на предмет имен классов, а затем генерируя все соответствующие CSS для этих стилей.

Чтобы Tailwind мог сгенерировать весь необходимый вам CSS, он должен знать о каждом отдельном файле в вашем проекте, который содержит любые имена классов Tailwind.

Сконфигурируйте пути ко всем вашим файлам содержимого в разделе `content` вашего файла конфигурации:

```js tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{html,js}',
    './components/**/*.{html,js}'
  ],
  // ...
}
```

Пути настроены как [glob patterns](https://en.wikipedia.org/wiki/Glob_(programming)), что упрощает сопоставление всех файлов содержимого в вашем проекте без тонкой настройки:

- Используйте `*` для соответствия чему угодно, кроме косой черты и скрытых файлов
- Используйте `**`, чтобы сопоставить ноль или более каталогов
- Используйте разделенные запятыми значения между `{}` для сопоставления со списком параметров

Tailwind использует внутреннюю библиотеку [fast-glob](https://github.com/mrmlnc/fast-glob) - ознакомьтесь с их документацией и другими поддерживаемыми функциями шаблонов.

Пути относятся к корню вашего проекта, а _не_ к вашему файлу `tailwind.config.js`, поэтому, если ваш файл `tailwind.config.js` находится в произвольном месте, вы все равно должны указывать свои пути относительно корня вашего проекта.

### Рекомендации по шаблону

Для наилучшей производительности и во избежание ложных срабатываний будьте как можно более конкретными в конфигурации вашего контента.

Если вы используете действительно широкий шаблон, подобный этому, Tailwind даже просканирует `node_modules` на предмет содержимого, которое, вероятно, не то, что вам нужно:

<TipBad>Не используйте слишком широкие шаблоны</TipBad>

```js tailwind.config.js
module.exports = {
  content: [
    './**/*.{html,js}',
  ],
  // ...
}
```

Если у вас есть какие-либо файлы, которые вам нужно просканировать, которые находятся в корне вашего проекта (часто это файл `index.html`), перечислите этот файл отдельно, чтобы другие ваши шаблоны могли быть более конкретными:

<TipGood>Будьте конкретны с вашими шаблонами контента</TipGood>

```js tailwind.config.js
module.exports = {
  content: [
    './components/**/*.{html,js}',
    './pages/**/*.{html,js}',
    './index.html',
  ],
  // ...
}
```

Некоторые фреймворки скрывают свою основную точку входа HTML в другом месте, чем остальные ваши шаблоны (часто `public/index.html`), поэтому, если вы добавляете классы Tailwind в этот файл, убедитесь, что он также включен в вашу конфигурацию:

<TipGood>Не забудьте свою точку входа HTML, если применимо</TipGood>

```js tailwind.config.js
  module.exports = {
    content: [
>     './public/index.html',
      './src/**/*.{html,js}',
    ],
    // ...
  }
```

Если у вас есть какие-либо файлы JavaScript, которые манипулируют вашим HTML для добавления классов, убедитесь, что вы также включили их:

```js tailwind.config.js
module.exports = {
  content: [
    // ...
    './src/**/*.js',
  ],
  // ...
}
```

```js src/spaghetti.js
// ...
menuButton.addEventListener('click', function () {
  let classList = document.getElementById('nav').classList
  classList.toggle('hidden')
  classList.toggle('block')
})
// ...
```

Также важно, чтобы вы не сканировали никакие файлы CSS - настройте Tailwind для сканирования ваших _шаблонах_, где используются имена ваших классов, а не файла CSS, который генерирует Tailwind.

<TipBad>Никогда не включайте файлы CSS в конфигурацию вашего контента</TipBad>

```js tailwind.config.js
module.exports = {
  content: [
    './src/**/*.css',
  ],
  // ...
}
```

### Детальное определение класса

Способ, которым Tailwind сканирует ваш исходный код на предмет классов, намеренно очень прост - на самом деле мы не анализируем и не выполняем какой-либо ваш код на языке, на котором он написан, мы просто используем регулярные выражения для извлечения каждой строки, которая может быть именем класса.

Например, вот некоторый HTML-код, в котором каждая строка потенциального имени класса отдельно выделена:

```html
<**div** **class**="**md:flex**">
  <**div** **class**="**md:flex-shrink-0**">
    <**img** **class**="**rounded-lg** **md:w-56**" **src**="**/img/shopping.jpg**" **alt**="**Woman** **paying** **for** **a** **purchase**">
  </**div**>
  <**div** **class**="**mt-4** **md:mt-0** **md:ml-6**">
    <**div** **class**="**uppercase** **tracking-wide** **text-sm** **text-indigo-600** **font-bold**">
      **Marketing**
    </**div**>
    <**a** **href**="**/get-started**" **class**="**block** **mt-1** **text-lg** **leading-tight** **font-semibold** **text-gray-900** **hover:underline**">
      **Finding** **customers** **for** **your** **new** **business**
    </**a**>
    <**p** **class**="**mt-2** **text-gray-600**">
      **Getting** **a** **new** **business** **off** **the** **ground** **is** **a** **lot** **of** **hard** **work.**
      **Here** **are** **five** **ideas** **you** **can** **use** **to** **find** **your** **first** **customers.**
    </**p**>
  </**div**>
</**div**>
```

Мы не ограничиваем наш поиск только атрибутами `class="..."`, потому что вы можете использовать классы где угодно, например, в некотором JavaScript для переключения меню:

```html spaghetti.js
<script>
  menuButton.addEventListener('click', function () {
    let classList = document.getElementById('nav').classList
    classList.toggle('**hidden**')
    classList.toggle('**block**')
  })
</script>
```

Используя этот очень простой подход, Tailwind чрезвычайно надежно работает с любым языком программирования, например, с JSX:

```jsx Button.jsx
const sizes = {
  md: 'px-4 py-2 rounded-md text-base',
  lg: 'px-5 py-3 rounded-lg text-lg',
}

const colors = {
  indigo: 'bg-indigo-500 hover:bg-indigo-600 text-white',
  cyan: 'bg-cyan-600 hover:bg-cyan-700 text-white',
}

export default function Button({ color, size, children }) {
  let colorClasses = colors[color]
  let sizeClasses = sizes[size]

  return (
    <button type="button" className={`font-bold ${sizeClasses} ${colorClasses}`}>
      {children}
    </button>
  )
}
```

Наиболее важным следствием того, как Tailwind извлекает имена классов, является то, что он найдет только те классы, которые существуют _в виде полных непрерывных строк_ в ваших исходных файлах.

Если вы используете строковую интерполяцию или объедините имена частичных классов вместе, Tailwind не найдет их и, следовательно, не сгенерирует соответствующий CSS:

<TipBad>Не создавайте имена классов динамически</TipBad>

```html
<div class="text-{{ error ? 'red' : 'green' }}-600"></div>
```

В приведенном выше примере строки `text-red-600` и `text-green-600` не существуют, поэтому Tailwind не будет генерировать эти классы.

Вместо этого убедитесь, что все имена классов, которые вы используете, существуют полностью:

<TipGood>Всегда используйте полные имена классов</TipGood>

```html
<div class="{{ error ? 'text-red-600' : 'text-green-600' }}"></div>
```

Пока вы всегда используете полные имена классов в своем коде, Tailwind каждый раз будет идеально генерировать весь ваш CSS.

### Работа со сторонними библиотеками

Если вы работаете с любыми сторонними библиотеками (например, [Select2](https://select2.org/)) и стилизуете эту библиотеку своим собственным CSS, мы рекомендуем писать эти стили _без_ использования Tailwind `@layer`:

```css main.css
@tailwind base;
@tailwind components;

.select2-dropdown {
  @apply rounded-b-lg shadow-md;
}
.select2-search {
  @apply border border-gray-300 rounded;
}
.select2-results__group {
  @apply text-lg font-bold text-gray-900;
}
/* ... */

@tailwind utilities;
```

Это гарантирует, что Tailwind _всегда_ включает эти стили в ваш CSS, что намного проще, чем настроить Tailwind для сканирования исходного кода сторонней библиотеки.

Если вы создали свой собственный многоразовый набор компонентов, стилизованных под Tailwind, и импортируете их в несколько проектов, обязательно сконфигурируйте Tailwind для сканирования этих компонентов на предмет имен классов:

```js tailwind.config.js
  module.exports = {
    content: [
      './components/**/*.{html,js}',
      './pages/**/*.{html,js}',
>     './node_modules/@my-company/tailwind-components/**/*.js',
    ],
    // ...
  }
```

Это гарантирует, что Tailwind также сгенерирует весь CSS, необходимый для этих компонентов.

### Настройка необработанного контента

Если по какой-либо причине вам нужно настроить Tailwind на сканирование необработанного содержимого, а не содержимого файла, используйте объект с ключом `raw` вместо пути:

```js tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{html,js}'
    './components/**/*.{html,js}',
    { raw: '<div class="font-bold">', extension: 'html' },
  ],
  // ...
}
```

Для этого не так много подходящих вариантов использования - обычно вы действительно хотите использовать [список надежных отправителей](#safelisting-classes).

---

## Классы безопасных списков

Для наименьшего размера файла и наилучшего опыта разработки мы настоятельно рекомендуем полагаться на вашу конфигурацию `content`, чтобы сообщить Tailwind, какие классы генерировать как можно больше.

Список надежных отправителей - это последнее средство, и его следует использовать только в тех случаях, когда невозможно сканировать определенный контент на предмет имен классов. Такие ситуации редки, и вам почти никогда не понадобится эта функция.

Если вам нужно убедиться, что Tailwind генерирует определенные имена классов, которых нет в ваших файлах содержимого, используйте опцию `safelist`:

```js tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{html,js}'
    './components/**/*.{html,js}',
  ],
  safelist: [
    'bg-red-500',
    'text-3xl',
    'lg:text-4xl',
  ]
  // ...
}
```

Одним из примеров того, где это может быть полезно, является то, что ваш сайт отображает контент, созданный пользователями, и вы хотите, чтобы пользователи могли использовать ограниченный набор классов Tailwind в своем контенте, который может не существовать в исходных файлах вашего собственного сайта.

### Использование регулярных выражений

Tailwind поддерживает списки надежных отправителей на основе шаблонов для ситуаций, когда вам нужно добавить в список надежных отправителей большое количество классов:

```js tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{html,js}',
    './components/**/*.{html,js}',
  ],
  safelist: [
    'text-2xl',
    'text-3xl',
    {
      pattern: /bg-(red|green|blue)-(100|200|300)/,
    },
  ],
  // ...
}
```

Шаблоны могут совпадать только с базовыми именами утилит, такими как `/bg-red-.+/`, и не будут совпадать, если шаблон включает модификатор варианта, такой как `/hover:bg-red-.+/`.

Если вы хотите заставить Tailwind генерировать варианты для любых совпадающих классов, включите их, используя опцию `variants`:

```js tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{html,js}',
    './components/**/*.{html,js}',
  ],
  safelist: [
    'text-2xl',
    'text-3xl',
    {
      pattern: /bg-(red|green|blue)-(100|200|300)/,
      variants: ['lg', 'hover', 'focus', 'lg:hover'],
    },
  ],
  // ...
}
```

---

## Преобразование исходных файлов

Если вы создаете контент в формате, который _компилируется_ в HTML (например, Markdown), часто имеет смысл скомпилировать этот контент в HTML _перед_ сканированием его на предмет имен классов.

Используйте опцию `content.transform` для преобразования любого контента, соответствующего определенному расширению файла, перед извлечением классов:

```js tailwind.config.js
const remark = require('remark')

module.exports = {
  content: {
    files: ['./src/**/*.{html,md}'],
    transform: {
      md: (content) => {
        return remark().process(content)
      }
    }
  },
  // ...
}
```

При использовании `content.transform`, вам необходимо указать исходные пути, используя `content.files` вместо массива верхнего уровня в разделе `content`.

---

## Настройка логики извлечения

Используйте опцию `extract`, чтобы переопределить логику, которую Tailwind использует для определения имен классов для определенных расширений файлов:

```js tailwind.config.js
module.exports = {
  content: {
    files: ['./src/**/*.{html,wtf}'],
    extract: {
      wtf: (content) => {
        return content.match(/[^<>"'`\s]*/)
      }
    }
  },
  // ...
}
```

Это расширенная функция, и большинству пользователей она не понадобится - логика извлечения по умолчанию в Tailwind работает очень хорошо почти для всех проектов.

Как и при преобразовании, при использовании `content.extract`, вам необходимо указать исходные пути, используя `content.files` вместо массива верхнего уровня в разделе `content`.

---

## Устранение неполадок

### Классы не генерируются

Если Tailwind не генерирует классы, убедитесь, что ваша конфигурация `content` верна и соответствует всем правильным исходным файлам.

Распространенной ошибкой является отсутствие расширения файла, например, если вы используете `jsx` вместо `js` для ваших компонентов React:

```diff-js tailwind.config.js
  module.exports = {
    content: [
-     './src/**/*.{html,js}',
+     './src/**/*.{html,js,jsx}'
    ],
    // ...
  }
```

Или создать новую папку в середине проекта, которая изначально не была охвачена, и забыть добавить ее в свою конфигурацию:

```diff-js tailwind.config.js
  module.exports = {
    content: [
      './pages/**/*.{html,js}',
      './components/**/*.{html,js}',
+     './util/**/*.{html,js}'
    ],
    // ...
  }
```

### Имена динамических классов

Как указано в [Подробное определение класса](#class-detection-in-depth), Tailwind на самом деле не запускает ваш исходный код и не обнаруживает динамически создаваемые имена классов.

<TipBad>Не создавайте имена классов динамически</TipBad>

```html
<div class="text-{{ error ? 'red' : 'green' }}-600"></div>
```

Убедитесь, что вы всегда используете полные имена классов в своем коде:

<TipGood>Всегда используйте полные имена классов</TipGood>

```html
<div class="{{ error ? 'text-red-600' : 'text-green-600' }}"></div>
```

### Стили перестраиваются в бесконечном цикле

Если кажется, что ваш CSS перестраивается в бесконечном цикле, есть большая вероятность, что ваш инструмент сборки не поддерживает параметр `glob` при [регистрации зависимостей PostCSS](https://github.com/postcss/postcss/blob/main/docs/guidelines/runner.md#31-rebuild-when-dependencies-change).

Многие инструменты сборки (например, webpack) не поддерживают эту опцию, и в результате мы можем сказать им только смотреть определенные файлы или _все каталоги_. Например, мы не можем указать webpack _только_ смотреть файлы `*.html` в каталоге.

Это означает, что если создание вашего CSS приводит к изменению _любых_ файлов в этих каталогах, будет запущена перестройка, даже если измененный файл не соответствует расширению в вашем glob.

```js tailwind.config.js
module.exports = {
  content: [
    // С некоторыми инструментами сборки ваш CSS будет перестраиваться
    // каждый раз, когда *любой* файл в `src` изменяется.
    './src/**/*.{html,js}',
  ],
  // ...
}
```

Итак, если вы следите за изменениями в `src/**/*.html`, но записываете выходной файл CSS в `src/css/styles.css`, вы получите бесконечный цикл перестройки с использованием некоторых инструментов.

В идеале мы могли бы предупредить вас об этом в консоли, но многие инструменты прекрасно это поддерживают (включая наш собственный инструмент CLI), и у нас нет надежного способа определить, какой инструмент сборки вы используете.

Чтобы решить эту проблему, используйте более конкретные пути в вашей конфигурации `content`, не забудьте включить только те каталоги, которые не изменятся при сборке CSS:

```diff-js tailwind.config.js
  module.exports = {
    content: [
-     './src/**/*.{html,js}',
+     './src/pages/**/*.{html,js}',
+     './src/components/**/*.{html,js}',
+     './src/layouts/**/*.{html,js}',
+     './src/index.html',
    ],
    // ...
  }
```

При необходимости отрегулируйте фактическую структуру каталогов проекта, чтобы убедиться, что вы можете настроить таргетинг на файлы шаблонов, не перехватывая случайно файл CSS или другие артефакты сборки, такие как файлы манифеста.

Если вы абсолютно не можете изменить конфигурацию содержимого или структуру каталогов, лучше всего скомпилировать CSS отдельно с помощью инструмента, который имеет полную поддержку glob. Мы рекомендуем использовать [Tailwind CLI](/docs/installation), который представляет собой быстрый, простой, специально созданный инструмент для компиляции вашего CSS с помощью Tailwind.

### Это просто не работает должным образом

Если у вас возникли странные, трудно описываемые проблемы с выходными данными или что-то просто не кажется, что они вообще работают, есть большая вероятность, что это связано с тем, что ваш инструмент сборки не поддерживает сообщения о зависимостях PostCSS должным образом _(или вообще)_. Одним из известных примеров этого в настоящее время является [Stencil](https://github.com/ionic-team/stencil-postcss/issues/38).

Когда у вас возникают такие проблемы, мы рекомендуем использовать [Tailwind CLI](/docs/installation) для отдельной компиляции CSS вместо того, чтобы пытаться интегрировать Tailwind в существующие инструменты.

Вы можете использовать такие пакеты, как `npm-run-all` или `concurrently`, чтобы скомпилировать ваш CSS вместе с вашей обычной командой разработки, добавив несколько скриптов в ваш проект, например:

```js
// package.json
{
  // ...
  "scripts": {
    "start": "concurrently \"npm run start:css\" \"react-scripts start\"",
    "start:css": "tailwindcss -o src/tailwind.css --watch",
    "build": "npm run build:css && react-scripts build",
    "build:css": "NODE_ENV=production tailwindcss -o src/tailwind.css -m",
  },
}
```
В любом случае обязательно [проверьте наличие существующей проблемы way, please be sure to [check for an existing issue](https://github.com/tailwindlabs/tailwindcss/issues) или [откройте новую](https://github.com/tailwindlabs/tailwindcss/issues/new/choose), чтобы мы могли выяснить проблему и попытаться улучшить совместимость с любым инструментом, который вы используете.
