---
title: "Использование с препроцессорами"
description: "Руководство по использованию Tailwind с распространенными препроцессорами CSS, такими как Sass, Less и Stylus."
---

import { TipGood, TipBad } from '@/components/Tip'

Поскольку Tailwind - это плагин PostCSS, ничто не мешает вам использовать его с Sass, Less, Stylus или другими препроцессорами, как и с другими плагинами PostCSS, такими как [Autoprefixer](https://github.com/postcss/autoprefixer).

Важно отметить, что **вам не нужно использовать препроцессор с Tailwind** - вы в любом случае обычно пишете очень мало CSS в проекте Tailwind, поэтому использование препроцессора не так полезно, как в проекте, где вы пишете много собственного CSS.

Это руководство существует только как справочник для людей, которым по той или иной причине необходимо или которые хотели бы интегрировать Tailwind с препроцессором.

---

## Использование PostCSS в качестве препроцессора

Если вы используете Tailwind для нового проекта и вам не нужно интегрировать его с какими-либо существующими таблицами стилей Sass/Less/Stylus, вам следует подумать о том, чтобы полагаться на другие плагины PostCSS для добавления функций препроцессора, которые вы используете вместо использования отдельного препроцессор.

У этого есть несколько преимуществ:

- **Ваши сборки будут быстрее**. Поскольку ваш CSS не нужно анализировать и обрабатывать несколькими инструментами, ваш CSS будет компилироваться намного быстрее, используя только PostCSS.
- **Никаких причуд или обходных путей.** Поскольку Tailwind добавляет некоторые новые нестандартные ключевые слова в CSS (например, `@tailwind`, `@apply`, `theme()` и т.д.), вам часто приходится писать свой CSS раздражающими, не интуитивными способами заставить препроцессор выдать ожидаемый результат. Работа исключительно с PostCSS позволяет избежать этого.

Достаточно полный список доступных плагинов PostCSS смотрите в [репозитории PostCSS GitHub](https://github.com/postcss/postcss/blob/master/docs/plugins.md), но вот несколько важных из них, которые мы используем на собственные проекты и могу рекомендовать.

### Импорт во время сборки

Одна из наиболее полезных функций, которые предлагают препроцессоры, - это возможность организовать ваш CSS в несколько файлов и объединить их во время сборки, предварительно обрабатывая операторы `@import`, а не в браузере.

Канонический плагин для обработки этого с помощью PostCSS - это [postcss-import](https://github.com/postcss/postcss-import).

Чтобы использовать его, установите плагин через npm:

```shell
# npm
npm install postcss-import

# yarn
yarn add postcss-import
```

Затем добавьте его как самый первый плагин в Вашу конфигурацию PostCSS:

```js
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-import'),
    require('tailwindcss'),
    require('autoprefixer'),
  ]
}
```

Важно отметить, что `postcss-import` строго соблюдает спецификацию CSS и запрещает операторы `@import` где угодно, кроме самого верха файла.

<TipBad>Не будет работать, операторы `@import` должны быть на первом месте</TipBad>

```css
/* components.css */

.btn {
  @apply px-4 py-2 rounded font-semibold bg-gray-200 text-black;
}

/* Не будет работать */
@import "./components/card";
```

Самое простое решение этой проблемы - никогда не смешивать обычный CSS и импорт в одном файле. Вместо этого создайте один основной файл точки входа для импорта и храните весь ваш фактический CSS в отдельных файлах.

<TipGood>Используйте отдельные файлы для импорта и собственно CSS</TipGood>

```css
/* components.css */
@import "./components/buttons.css";
@import "./components/card.css";
```

```css
/* components/buttons.css */
.btn {
  @apply px-4 py-2 rounded font-semibold bg-gray-200 text-black;
}
```

```css
/* components/card.css */
.card {
  @apply p-4 bg-white shadow rounded;
}
```

Скорее всего, вы столкнетесь с такой ситуацией в Вашем основном файле CSS, который включает Ваши объявления `@tailwind`.

<TipBad>Не будет работать, операторы `@import` должны быть на первом месте</TipBad>

```css
@tailwind base;
@import "./custom-base-styles.css";

@tailwind components;
@import "./custom-components.css";

@tailwind utilities;
@import "./custom-utilities.css";
```

Вы можете решить эту проблему, создав отдельные файлы для каждого объявления `@tailwind`, а затем импортируя эти файлы в вашу основную таблицу стилей. Чтобы упростить это, мы предоставляем отдельные файлы для каждого объявления `@tailwind` из коробки, которые вы можете импортировать непосредственно из `node_modules`.

Плагин `postcss-import` достаточно умен, чтобы автоматически искать файлы в папке `node_modules`, поэтому вам не нужно указывать полный путь - например, достаточно `"tailwindcss/base"`.

<TipGood>Импортируйте предоставленные файлы CSS</TipGood>

```css
@import "tailwindcss/base";
@import "./custom-base-styles.css";

@import "tailwindcss/components";
@import "./custom-components.css";

@import "tailwindcss/utilities";
@import "./custom-utilities.css";
```

### Вложенность

Чтобы добавить поддержку вложенных объявлений, у вас есть два варианта:

- [postcss-nested](https://github.com/postcss/postcss-nested), который использует синтаксис, очень похожий на Sass.

- [postcss-nesting](https://github.com/jonathantneal/postcss-nesting), который следует за [CSS Nesting](https://drafts.csswg.org/css-nesting-1/) спецификация, которая, надеюсь, будет доступна прямо в браузере в будущем.

Чтобы использовать любой из этих плагинов, установите их через npm:

```shell
# npm
npm install postcss-nested  # или postcss-nesting

# yarn
yarn add postcss-nested  # или postcss-nesting
```

Затем добавьте их в свою конфигурацию PostCSS, где-нибудь после самого Tailwind, но до Autoprefixer:

```js
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-import'),
    require('tailwindcss'),
    require('postcss-nested'), // или require('postcss-nesting')
    require('autoprefixer'),
  ]
}
```

### Переменные

В наши дни переменные CSS (официально известные как настраиваемые свойства) имеют действительно хорошую [поддержку браузера](https://caniuse.com/#search=css%20custom%20properties), так что вам может вообще не понадобиться плагин для переменных.

Однако, если вам нужно поддерживать IE11, вы можете использовать плагин [postcss-custom-properties](https://github.com/postcss/postcss-custom-properties) для автоматического создания резервных вариантов для Ваших переменных.

Чтобы использовать его, установите его через npm:

```shell
# npm
npm install postcss-custom-properties

# yarn
yarn add postcss-custom-properties
```

Затем добавьте его в конфигурацию PostCSS, где-нибудь после самого Tailwind, но перед Autoprefixer:

```js
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-import'),
    require('tailwindcss'),
    require('postcss-nested'),
    require('postcss-custom-properties'),
    require('autoprefixer'),
  ]
}
```

### Будущие возможности CSS

Вы можете добавить поддержку десятков будущих функций CSS в свой проект с помощью плагина [postcss-preset-env](https://github.com/csstools/postcss-preset-env).

Чтобы использовать его, установите его через npm:

```shell
# npm
npm install postcss-preset-env

# yarn
yarn add postcss-preset-env
```

Затем добавьте его в конфигурацию PostCSS где-нибудь после самого Tailwind:

```js
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-import'),
    require('tailwindcss'),
    require('postcss-preset-env')({ stage: 1 }),
  ]
}
```

**Важно отметить, что переменные CSS, вложение и автопрефиксатор включены в готовые**, поэтому, если вы используете `postcss-preset-env`, вам не нужно добавлять отдельные плагины для эти особенности.

---

## Использование Sass, Less или Stylus

Чтобы использовать Tailwind с инструментом предварительной обработки, таким как Sass, Less или Stylus, вам необходимо добавить в проект дополнительный этап сборки, который позволит вам запускать предварительно обработанный CSS через PostCSS. Если вы используете Autoprefixer в своем проекте, у вас уже есть что-то подобное.

Точные инструкции будут отличаться в зависимости от того, какой инструмент сборки вы используете, поэтому смотрите нашу [документацию по установке](/docs/installation#3-process-your-css-with-tailwind), чтобы узнать больше об интеграции Tailwind в существующую сборку. процесс.

Самое важное, что нужно понимать при использовании Tailwind с препроцессором, - это то, что **препроцессоры, такие как Sass, Less и Stylus, запускаются отдельно перед Tailwind**. Это означает, что вы не можете передать вывод функции Tailwind `theme()`, например, в цветовую функцию Sass, потому что функция `theme()` фактически не оценивается, пока ваш Sass не будет скомпилирован в CSS и передан в PostCSS.

<TipBad>Не будет работать, сначала обрабатывается Sass</TipBad>

```css
.alert {
  background-color: darken(theme('colors.red.500'), 10%);
}
```

Для наиболее согласованной разработки рекомендуется [использовать исключительно PostCSS](#using-post-css-as-your-preprocessor).

Помимо этого, каждый препроцессор имеет свои собственные причуды при использовании с Tailwind, обходные пути которых описаны ниже.

### Sass

При использовании Tailwind с Sass использование `!important` с `@apply` требует, чтобы вы использовали интерполяцию для правильной компиляции.

<TipBad>Не будет работать, на что жалуется Sass !important</TipBad>

```css
.alert {
  @apply bg-red-500 !important;
}
```

<TipGood>Используйте интерполяцию как обходной путь</TipGood>

```css
.alert {
  @apply bg-red-500 #{!important};
}
```

### Less

При использовании Tailwind с Less вы не можете вложить директиву Tailwind `@screen`.

<TipBad>Не будет работать, Less  не понимает, что это медиа-запрос</TipBad>

```css
.card {
  @apply rounded-none;

  @screen sm {
    @apply rounded-lg;
  }
}
```

Вместо этого используйте обычный медиа-запрос вместе с функцией `theme()` для ссылки на размеры вашего экрана или просто не вкладывайте свои директивы `@screen`.

<TipGood>Используйте обычный медиа-запрос и theme()</TipGood>

```css
.card {
  @apply rounded-none;

  @media (min-width: theme('screens.sm')) {
    @apply rounded-lg;
  }
}
```

<TipGood>Используйте директиву @screen на верхнем уровне</TipGood>

```css
.card {
  @apply rounded-none;
}
@screen sm {
  .card {
    @apply rounded-lg;
  }
}
```

### Stylus

При использовании Tailwind со Stylus вы не можете использовать функцию Tailwind `@apply`, не заключив все правило CSS в `@css`, чтобы Stylus воспринимал его как буквальный CSS:

<TipBad>Не сработает, Stylus жалуется на @apply</TipBad>

```css
.card {
  @apply rounded-lg bg-white p-4
}
```

<TipGood>Используйте @css, чтобы избежать обработки как Stylus</TipGood>

```css
@css {
  .card {
    @apply rounded-lg bg-white p-4
  }
}
```

Однако это требует значительных затрат, а именно: **вы не можете использовать какие-либо функции стилуса внутри блока `@css`**.

Другой вариант - использовать функцию `theme()` вместо `@apply` и записать фактические свойства CSS в длинной форме:

<TipGood>Используйте theme() вместо @apply</TipGood>

```css
.card {
  border-radius: theme('borderRadius.lg');
  background-color: theme('colors.white');
  padding: theme('spacing.4');
}
```

Вдобавок к этому Stylus не поддерживает вложение директивы `@screen` (как и Less).

<TipBad>Не сработает, Stylus не понимает, что это медиа-запрос</TipBad>

```css
.card {
  border-radius: 0;

  @screen sm {
    border-radius: theme('borderRadius.lg');
  }
}
```

Вместо этого используйте обычный медиа-запрос вместе с функцией `theme()` для ссылки на размеры Вашего экрана или просто не вкладывайте свои директивы `@screen`.

<TipGood>Используйте обычный медиа-запрос и theme()</TipGood>

```css
.card {
  border-radius: 0;

  @media (min-width: theme('screens.sm')) {
    border-radius: theme('borderRadius.lg');
  }
}
```

<TipGood>Используйте директиву @screen на верхнем уровне</TipGood>

```css
.card {
  border-radius: 0;
}
@screen sm {
  .card {
    border-radius: theme('borderRadius.lg');
  }
}
```
